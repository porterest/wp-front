File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/__init__.py
----------------------------------------

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/__init__.py
----------------------------------------
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker

from settings import settings

__all__ = [
    "session_maker",
]

engine = create_async_engine(settings.db.url, echo=False)
session_maker = async_sessionmaker(engine, expire_on_commit=False)

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/BlockRepository.py
----------------------------------------
from typing import Optional

from abstractions.repositories.block import BlockRepositoryInterface
from domain.dto.block import CreateBlockDTO, UpdateBlockDTO
from domain.models.block import Block as BlockModel
from infrastructure.db.entities import Block
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository


class BlockRepository(
    AbstractSQLAlchemyRepository[Block, BlockModel, CreateBlockDTO, UpdateBlockDTO],
    BlockRepositoryInterface
):
    async def get_last_block(self) -> Optional[Block]:
        # todo: implement
        ...

    async def save(self, block: Block) -> None:
        # todo: implement
        ...

    def create_dto_to_entity(self, dto: CreateBlockDTO) -> Block:
        return Block(
            block_number=dto.block_number,
            status=dto.status,
            result_vector=dto.result_vector,
            created_at=dto.created_at,
            completed_at=dto.completed_at,
        )

    def entity_to_model(self, entity: Block) -> BlockModel:
        return BlockModel(
            block_number=entity.block_number,
            status=entity.status,
            result_vector=entity.result_vector,
            created_at=entity.created_at,
            completed_at=entity.completed_at,
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/BetRepository.py
----------------------------------------
from domain.dto.bet import CreateBetDTO, UpdateBetDTO
from domain.models.bet import Bet as BetModel
from infrastructure.db.entities import Bet
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository


# TODO: интерфейс

class BetRepository(
    AbstractSQLAlchemyRepository[Bet, BetModel, CreateBetDTO, UpdateBetDTO]
):

    # TODO: кажется тут что-то не так
    def create_dto_to_entity(self, dto: CreateBetDTO) -> Bet:
        return Bet(
            user_id=dto.user_id,
            pair_id=dto.pair_id,
            amount=dto.amount,
            block_number=dto.block_number,
            vector=dto.vector,
            status=dto.status
        )

    def entity_to_model(self, entity: Bet) -> BetModel:
        return BetModel(
            user_id=entity.user_id,
            pair_id=entity.pair_id,
            amount=entity.amount,
            block_number=entity.block_number,
            vector=entity.vector,
            status=entity.status,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/TransactionRepository.py
----------------------------------------
from domain.dto.transaction import CreateTransactionDTO, UpdateTransactionDTO
from domain.models.transaction import Transaction as TransactionModel
from infrastructure.db.entities import Transaction
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository

# todo: same
class TransactionRepository(
    AbstractSQLAlchemyRepository[Transaction, TransactionModel, CreateTransactionDTO, UpdateTransactionDTO]
):
    def create_dto_to_entity(self, dto: CreateTransactionDTO) -> Transaction:
        return Transaction(
            user_id=dto.user_id,
            type=dto.type,
            amount=dto.amount
        )

    def entity_to_model(self, entity: Transaction) -> TransactionModel:
        return TransactionModel(
            user_id=entity.user_id,
            type=entity.type,
            amount=entity.amount,
            tx_id=entity.tx_id,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/PairRepository.py
----------------------------------------
from abstractions.repositories.pair import PairRepositoryInterface
from domain.dto.pair import CreatePairDTO, UpdatePairDTO
from domain.models.pair import Pair as PairModel
from infrastructure.db.entities import Pair
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository


class PairRepository(
    AbstractSQLAlchemyRepository[Pair, PairModel, CreatePairDTO, UpdatePairDTO],
    PairRepositoryInterface,
):
    def create_dto_to_entity(self, dto: CreatePairDTO) -> Pair:
        return Pair(
            name=dto.name,
            contract_address=dto.contract_address
        )

    # TODO: same
    def entity_to_model(self, entity: Pair) -> PairModel:
        return PairModel(
            pair_id=entity.id,
            name=entity.name,
            contract_address=entity.contract_address,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/AggregatedDataRepository.py
----------------------------------------
from domain.dto.aggregated_data import CreateAggregatedDataDTO, UpdateAggregatedDataDTO
from domain.models.aggregated_data import AggregatedData as AggregatedDataModel
from infrastructure.db.entities import AggregatedData
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository

# todo: same
class AggregatedDataRepository(
    AbstractSQLAlchemyRepository[AggregatedData, AggregatedDataModel, CreateAggregatedDataDTO, UpdateAggregatedDataDTO]
):
    def create_dto_to_entity(self, dto: CreateAggregatedDataDTO) -> AggregatedData:
        return AggregatedData(
            id=dto.id,
            block_number=dto.block_number,
            aggregated_vector=dto.aggregated_vector,
            ordinal_present=dto.ordinal_present,
            aggregate_bet_amount=dto.aggregate_bet_amount,
        )

    def entity_to_model(self, entity: AggregatedData) -> AggregatedDataModel:
        return AggregatedDataModel(
            id=entity.id,
            block_number=entity.block_number,
            aggregated_vector=entity.aggregated_vector,
            ordinal_present=entity.ordinal_present,
            aggregate_bet_amount=entity.aggregate_bet_amount,
            wallet_address=entity.wallet_address,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/ChainRepository.py
----------------------------------------
from domain.dto.chain import CreateChainDTO, UpdateChainDTO
from domain.models.chain import Chain as ChainModel
from infrastructure.db.entities import Chain
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository


# todo: same!
class ChainRepository(
    AbstractSQLAlchemyRepository[Chain, ChainModel, CreateChainDTO, UpdateChainDTO],
):
    def create_dto_to_entity(self, dto: CreateChainDTO) -> Chain:
        return Chain(
            id=dto.id,
            current_block=dto.current_block,
            last_update=dto.last_update,
            created_at=dto.created_at,
            status=dto.status
        )

    def entity_to_model(self, entity: Chain) -> ChainModel:
        return ChainModel(
            id=entity.id,
            current_block=entity.current_block,
            last_update=entity.last_update,
            created_at=entity.created_at,
            status=entity.status
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/__init__.py
----------------------------------------
from .AbstractRepository import AbstractSQLAlchemyRepository
from .AbstractUOW import AbstractSQLAlchemyUOW

__all__ = [
    "AbstractSQLAlchemyRepository",
    "AbstractSQLAlchemyUOW",
]

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/BalanceRepository.py
----------------------------------------
from domain.dto.balance import CreateBalanceDTO, UpdateBalanceDTO
from domain.models.balance import Balance as BalanceModel, Balance
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository


# todo: same
class BalanceRepository(
    AbstractSQLAlchemyRepository[Balance, BalanceModel, CreateBalanceDTO, UpdateBalanceDTO]
):
    def create_dto_to_entity(self, dto: CreateBalanceDTO) -> Balance:
        return Balance(
            user_id=dto.user_id,
            balance=dto.balance,
            token_type=dto.token_type
        )

    def entity_to_model(self, entity: Balance) -> BalanceModel:
        return BalanceModel(
            balance=entity.balance,
            token_type=entity.token_type,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/AbstractRepository.py
----------------------------------------
from abc import abstractmethod
from dataclasses import dataclass
from typing import Type

from sqlalchemy import select
from sqlalchemy.ext.asyncio import async_sessionmaker

from abstractions.repositories import CRUDRepositoryInterface


@dataclass
class AbstractSQLAlchemyRepository[Entity, Model, CreateDTO, UpdateDTO](
    CRUDRepositoryInterface[Model, CreateDTO, UpdateDTO]
):
    session_maker: async_sessionmaker

    def __post_init__(self):
        self.entity: Type[Entity] = self.__orig_bases__[0].__args__[0]

    async def create(self, obj: CreateDTO) -> None:
        async with self.session_maker() as session:
            async with session.begin():
                session.add(self.create_dto_to_entity(obj))

    async def get(self, obj_id: str) -> Model:
        # TODO: тоже не знаю, что лучше - поднимать ошибку при отсутствии или возврщать None?
        #  как будто ошибка круче (тк None вместо сущности не имеет ценности) но надо подумать немного
        async with self.session_maker() as session:
            res = await session.get(self.entity, obj_id)
            obj = res.scalars().one()
            return self.entity_to_model(obj)

    async def update(self, obj_id: str, obj: UpdateDTO) -> None:
        # TODO: не уверен какое поведение должно быть относительно None и отсутствующих атрибутов
        #  (в какой ситуации ставить null, в какой не изменять атрибут.)
        #  это также определяется различиями между моделями слоев (updatedto/model/entity)
        async with self.session_make() as session:
            async with session.begin():
                entity = await session.get(self.entity, obj_id)
                for key, value in obj.__dict__.items():
                    setattr(entity, key, value)

    async def delete(self, obj_id: str) -> None:
        # TODO: soft delete? вроде сейчас не надо, или надо?
        async with self.session_maker() as session:
            async with session.begin():
                obj = await session.get(self.entity, obj_id)
                await session.delete(obj)

    async def get_all(self, limit: int = 100, offset: int = 0) -> list[Model]:
        async with self.session_maker() as session:
            return [
                self.entity_to_model(entity)
                for entity in (await session.execute(
                    select(self.entity)
                    .limit(limit)
                    .offset(offset)
                )).scalars().all()
            ]

    # TODO: возможно есть способ получше?
    #  меня бесит необходимость дублирования кода в разных репозиториях для вложенных сущностей
    @abstractmethod
    def entity_to_model(self, entity: Entity) -> Model:
        ...

    @abstractmethod
    def create_dto_to_entity(self, dto: CreateDTO) -> Entity:
        ...

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/AppWalletRepository.py
----------------------------------------
from domain.dto.app_wallet import CreateAppWalletDTO, UpdateAppWalletDTO
from domain.models.app_wallet import AppWallet as AppWalletModel
from infrastructure.db.entities import AppWallet
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository

# todo: same (у меня кстати есть изменения в эту сущность)
class AppWalletRepository(
    AbstractSQLAlchemyRepository[AppWallet, AppWalletModel, CreateAppWalletDTO, UpdateAppWalletDTO]
):
    def create_dto_to_entity(self, dto: CreateAppWalletDTO) -> AppWallet:
        return AppWallet(
            address=dto.address,
            wallet_type=dto.wallet_type,
            balance=dto.balance
        )

    def entity_to_model(self, entity: AppWallet) -> AppWalletModel:
        return AppWalletModel(
            wallet_id=entity.id,
            address=entity.address,
            wallet_type=entity.wallet_type,
            balance=entity.balance,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
        )

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/UserRepository.py
----------------------------------------
from sqlalchemy import select

from abstractions.repositories.user import UserRepositoryInterface
from domain.dto.user import CreateUserDTO, UpdateUserDTO
from domain.models.user import User as UserModel
from infrastructure.db.entities import User
from infrastructure.db.repositories.AbstractRepository import AbstractSQLAlchemyRepository


class UserRepository(
    AbstractSQLAlchemyRepository[User, UserModel, CreateUserDTO, UpdateUserDTO],
    UserRepositoryInterface,
):
    def create_dto_to_entity(self, dto: CreateUserDTO) -> User:
        return User(
            username=dto.username,
            first_name=dto.first_name,
            last_name=dto.last_name,
            last_activity=dto.last_activity
        )

    def entity_to_model(self, entity: User) -> UserModel:
        return UserModel(
            id=entity.id,
            telegram_id=entity.telegram_id,
            username=entity.username,
            first_name=entity.first_name,
            last_name=entity.last_name,
            last_activity=entity.last_activity,
            created_at=entity.created_at,
            updated_at=entity.updated_at,
        )

    async def get_by_wallet(self, wallet_address: str) -> UserModel:
        async with self.session_maker() as session:
            res = await session.execute(
                select(User)
                .where(
                    self.entity.wallet_address == wallet_address,
                )
            )
            return res.scalars().one_or_none()
================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/repositories/AbstractUOW.py
----------------------------------------
from contextlib import asynccontextmanager
from dataclasses import dataclass
from typing import Callable, AsyncContextManager

from sqlalchemy.ext.asyncio import async_sessionmaker, AsyncSession

from abstractions.repositories import UOWInterface
from infrastructure.db.repositories import AbstractSQLAlchemyRepository


@dataclass
class AbstractSQLAlchemyUOW(
    UOWInterface
):
    session_maker: async_sessionmaker
    _session = None
    _repositories = []

    class FakeSession:
        def __init__(self, session):
            self._session = session

        async def close(self):
            pass

        async def commit(self):
            pass

        async def rollback(self):
            pass

        def begin(self):
            return self

        async def __aenter__(self):
            return self

        async def __aexit__(self, exc_type, exc_val, exc_tb):
            return False

        def __getattr__(self, item):
            try:
                return self._session.__getattribute__(item)
            except AttributeError:
                return self.__getattribute__(item)

    async def commit(self) -> None:
        await self._session.commit()

    async def rollback(self) -> None:
        await self._session.rollback()

    @classmethod
    def create_fake_session_maker(cls, session) -> Callable[[None], AsyncContextManager[AsyncSession]]:
        @asynccontextmanager
        async def session_maker():
            yield cls.FakeSession(session=session)

        return session_maker

    async def attach(self, *repositories: AbstractSQLAlchemyRepository) -> 'AbstractSQLAlchemyUOW':
        self._repositories = repositories
        return self

    async def __aenter__(self) -> 'AbstractSQLAlchemyUOW':
        self._session = self.session_maker()
        session_maker = self.create_fake_session_maker(self._session)
        for repository in self._repositories:
            repository.session_maker = session_maker
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if exc_type:
            await self.rollback()
        else:
            await self.commit()
        await self._session.close()
        self._session = None
        self._repositories = []
        return False

================================================================================

File: /Users/daria/PycharmProjects/donald-front/backend/app/infrastructure/db/entities/__init__.py
----------------------------------------
from datetime import datetime
from enum import Enum as PyEnum
from typing import Optional, Tuple, List
from uuid import UUID
from uuid import UUID as pyUUID

from sqlalchemy import ForeignKey, Enum as SQLEnum, BigInteger
from sqlalchemy import String, DateTime, Integer, Enum, func
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import relationship, Mapped, mapped_column

from domain.enums import BetStatus, TransactionType, WalletType
from domain.enums.deposit import DepositEntryStatus

Base = declarative_base()


class AbstractBase(Base):
    __abstract__ = True

    created_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now)
    updated_at: Mapped[datetime] = mapped_column(DateTime, default=datetime.now, onupdate=datetime.now)


class User(AbstractBase):
    __tablename__ = 'users'

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    telegram_id: Mapped[int] = mapped_column(BigInteger, unique=True, index=True)
    username: Mapped[Optional[str]] = mapped_column(String(255), unique=True)
    first_name: Mapped[Optional[str]] = mapped_column(String(255))
    last_name: Mapped[Optional[str]] = mapped_column(String(255))
    last_activity: Mapped[Optional[datetime]]

    wallet_address: Mapped[Optional[str]]

    balances = relationship("Balance", back_populates="user")
    bets = relationship("Bet", back_populates="user")
    transactions = relationship("Transaction", back_populates="user")
    deposit = relationship('DepositEntry', back_populates='user')
    balance: Mapped[float]


class Bet(AbstractBase):
    __tablename__ = 'bets'

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    user_id: Mapped[pyUUID] = mapped_column(ForeignKey('users.id'))
    pair_id: Mapped[pyUUID] = mapped_column(ForeignKey('pairs.id'), index=True)
    amount: Mapped[float]
    block_number: Mapped[int] = mapped_column(index=True)
    vector: Mapped[dict] = mapped_column(JSONB)
    status: Mapped[BetStatus] = mapped_column(SQLEnum(BetStatus), default=BetStatus.PENDING)

    user = relationship("User", back_populates="bets")
    pair = relationship("Pair", back_populates="bets")


class Transaction(AbstractBase):
    __tablename__ = 'transactions'

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    tx_id: Mapped[Optional[str]] = mapped_column(unique=True)
    user_id: Mapped[pyUUID] = mapped_column(ForeignKey('users.id'))
    type: Mapped[TransactionType] = mapped_column(SQLEnum(TransactionType), index=True)
    amount: Mapped[float]

    sender: Mapped[str]
    recipient: Mapped[str]

    user = relationship("User", back_populates="transactions")

class Pair(AbstractBase):
    __tablename__ = 'pairs'

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    name: Mapped[str] = mapped_column(String(50))
    contract_address: Mapped[str] = mapped_column(String(255), unique=True)
    last_ratio: Mapped[float]

    bets = relationship("Bet", back_populates="pair")


class AggregatedData(AbstractBase):
    __tablename__ = 'aggregated_data'

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    block_number: Mapped[int]
    aggregated_vector: Mapped[dict] = mapped_column(JSONB)
    ordinal_present: Mapped[bool]
    aggregate_bet_amount: Mapped[float]


class AppWallet(AbstractBase):
    __tablename__ = 'app_wallets'

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    address: Mapped[str] = mapped_column(String(255))
    wallet_type: Mapped[WalletType] = mapped_column(SQLEnum(WalletType))
    balance: Mapped[float]

    deposits = relationship("DepositEntry", back_populates="app_wallet")


class DepositEntry(AbstractBase):
    __tablename__ = 'deposit_entries'

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    app_wallet_id: Mapped[pyUUID] = mapped_column(ForeignKey('app_wallets.id'))
    user_id: Mapped[UUID] = mapped_column(ForeignKey('users.id'))

    status: Mapped[DepositEntryStatus] = mapped_column(SQLEnum(DepositEntryStatus))

    amount: Mapped[Optional[float]]
    tx_id: Mapped[Optional[str]]

    app_wallet = relationship("AppWallet", back_populates="deposits")
    user = relationship('User', back_populates='deposits')

class BlockStatus(PyEnum):
    COMPLETED = "completed"
    IN_PROGRESS = "in_progress"
    INTERRUPTED = "interrupted"


class Block(AbstractBase):
    __tablename__ = "blocks"

    id: Mapped[pyUUID] = mapped_column(UUID(as_uuid=True), primary_key=True)
    block_number: Mapped[int] = mapped_column(Integer, unique=True, nullable=False)
    status: Mapped[BlockStatus] = mapped_column(Enum(BlockStatus), nullable=False, default=BlockStatus.IN_PROGRESS)
    created_at: Mapped[Optional[DateTime]] = mapped_column(DateTime(timezone=True), server_default=func.now())
    completed_at: Mapped[Optional[DateTime]] = mapped_column(DateTime(timezone=True), nullable=True)
    result_vector: Mapped[Tuple[float, float]] = mapped_column(JSONB, nullable=True)
    bets: Mapped[List["Bet"]] = relationship("Bet", back_populates="block")


class ChainStatus(Enum):
    ACTIVE = "active"
    PAUSED = "paused"
    COMPLETED = "completed"

class Chain(Base):
    __tablename__ = "chains"

    id: Mapped[UUID] = mapped_column(UUID(as_uuid=True), primary_key=True, default=uuid4)
    current_block: Mapped[int] = mapped_column(Integer, nullable=False)
    status: Mapped[ChainStatus] = mapped_column(Enum(ChainStatus), nullable=False, default=ChainStatus.ACTIVE)
    created_at: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), server_default=func.now())
    last_update: Mapped[Optional[datetime]] = mapped_column(DateTime(timezone=True), onupdate=func.now())

================================================================================

